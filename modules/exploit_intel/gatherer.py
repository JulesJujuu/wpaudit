import os
from core.utils import get_scan_filename_prefix # For log naming consistency
from .query_builder import build_search_queries
from .searchsploit_handler import search_searchsploit
from .metasploit_handler import search_metasploit

def run_scan(state, config):
    """
    Orchestrates the gathering of exploit intelligence.
    Builds queries, searches SearchSploit, searches Metasploit,
    generates guidance, and handles optional autorun.
    """
    print("\n[*] Phase Exploit Intel: Gathering Exploit Intelligence")
    module_key = "exploit_intelligence"

    # Initialize findings structure (ensure all keys are present)
    initial_findings = {
        "search_queries_tried": [],
        "found_exploits": {}, # Keyed by query: {"searchsploit": [], "metasploit": []}
        "exploit_guidance": {
            "manual_searchsploit_cmds": [],
            "generated_msf_rc_files": []
        },
        "autorun_attempts": [], # List of dicts from Metasploit autorun
        "status": "Running"
    }
    state.update_module_findings(module_key, initial_findings)

    # 1. Build Search Queries
    queries_to_run_list = build_search_queries(state)
    
    current_findings = state.get_module_findings(module_key) # Get the initialized findings
    current_findings["search_queries_tried"] = queries_to_run_list
    state.update_module_findings(module_key, current_findings)

    if not queries_to_run_list:
        print("[i] No specific items identified for exploit search. Skipping Exploit Intel phase.")
        current_findings["status"] = "Skipped (No Queries)"
        state.update_module_findings(module_key, current_findings)
        return

    # Prepare local accumulators for results
    all_found_exploits_dict = {} # Aggregates all exploit details
    all_manual_searchsploit_cmds = []
    all_generated_msf_rc_files = []
    all_autorun_attempts = []

    # Get tool availability from state (checked by tool_checker.py and stored)
    tool_checks = state.get_full_state().get("tool_checks", {})
    searchsploit_available = tool_checks.get("searchsploit", {}).get("status") == "Found"
    msfconsole_available = tool_checks.get("msfconsole", {}).get("status") == "Found"

    # LHOST and LPORT for Metasploit RC scripts and autorun
    lhost_for_rc = config.get("exploit_intel_autorun_lhost", "127.0.0.1")
    # current_lport is passed as a list to allow modification by reference (Python's way for int)
    current_lport_ref = [config.get("exploit_intel_autorun_lport_start", 4444)]

    base_scan_prefix_for_log = get_scan_filename_prefix(state, config)

    for query in queries_to_run_list:
        if not query or len(query) < 3:
            continue
        print(f"\n    Processing query: '{query}'")
        all_found_exploits_dict.setdefault(query, {"searchsploit": [], "metasploit": []})

        # 2. SearchSploit
        if searchsploit_available:
            ss_exploits, ss_manual_cmds = search_searchsploit(state, config, query, base_scan_prefix_for_log)
            if ss_exploits:
                all_found_exploits_dict[query]["searchsploit"].extend(ss_exploits)
            if ss_manual_cmds:
                all_manual_searchsploit_cmds.extend(ss_manual_cmds)
        else:
            print(f"      [i] Skipping SearchSploit for '{query}' (Tool not available).")

        # 3. Metasploit Search (focused on CVEs)
        is_cve_for_msf = query.upper().startswith("CVE-")
        if is_cve_for_msf and msfconsole_available:
            msf_exploits, msf_rc_files, msf_autoruns = search_metasploit(
                state, config, query, base_scan_prefix_for_log, lhost_for_rc, current_lport_ref
            )
            if msf_exploits:
                all_found_exploits_dict[query]["metasploit"].extend(msf_exploits)
            if msf_rc_files:
                all_generated_msf_rc_files.extend(msf_rc_files)
            if msf_autoruns:
                all_autorun_attempts.extend(msf_autoruns)
        elif msfconsole_available and not is_cve_for_msf:
            print(f"      [i] Skipping Metasploit search for non-CVE query '{query}'.")
        elif not msfconsole_available and is_cve_for_msf:
             print(f"      [i] Skipping Metasploit search for '{query}' (Tool not available).")


    # --- Final State Update ---
    final_findings = state.get_module_findings(module_key) # Get current state again
    final_findings["found_exploits"] = all_found_exploits_dict
    final_findings["exploit_guidance"]["manual_searchsploit_cmds"] = all_manual_searchsploit_cmds
    final_findings["exploit_guidance"]["generated_msf_rc_files"] = all_generated_msf_rc_files
    final_findings["autorun_attempts"] = all_autorun_attempts
    final_findings["status"] = "Completed"
    state.update_module_findings(module_key, final_findings)

    print("\n[*] Exploit Intel phase finished.")
    # The main.py loop will handle state.mark_phase_executed("exploit_intel") and state.save_state()
